# 指令格式

DustISA采用了一种自描述的指令格式，即指令本身就表达了应该如何解析指令。

## 指令结构

DustISA采用32位指令，所有的指令在内存中需要按照32位对齐。

指令的32位被划分为如下的形式：

```
XXX XXX X    XXXXXX X    XXX  XXXXXX X    XXXXXX XX
SET CLA NUM0 R0     NUM1 INST R1     NUM2 R2     ATTR
```

指令解码器在解析时，需要按照如下规则进行解析：

- SET：区分了不同的子指令集
- CLA：在子指令集中区分区分指令种类
- NUM0：如果为1，则R0后的指令被编码为18位立即数
- R0：0号寄存器或栈空间
- NUM1：如果为1，则INST后的指令被编码为14位立即数
- R1: 1号寄存器或栈空间
- NUM2：如果为1，则R2与ATTR被编码为8位立即数
- R2: 2号栈空间或寄存器
- ATTR: 额外的控制参数

## 寄存器或栈空间

指令结构中的R0, R1, R2表达的可以是通用寄存器，或者是栈帧中的某一个地址。最高位为0时则为通用寄存，1位栈帧空间。

### 通用寄存器

DustISA存在32个通用寄存器，其中

- r0为0寄存器
- r1-r31为普通寄存器

### 特殊寄存器

特殊寄存器是无法被指令参数直接访问，需要间接的通过特殊指令访问。这类的寄存器数量不固定，有可能被子指令集扩展。

- PC：指令计数寄存器，永远为32对齐
- SF：栈帧寄存器，永远为32对齐，是指令参数指令为栈空间时的基础偏移量。

### 栈帧空间

SF寄存器会随着函数调用的过程进行增减。由于指令参数有32个取值的可能性，因此随着栈帧的生成与销毁，此寄存器会增加或减少32*字长的偏移量。

假设当前平台字长为64字节，则指令参数读取的栈帧地址为：

SF寄存器 + 栈帧空间编号 * 字长
