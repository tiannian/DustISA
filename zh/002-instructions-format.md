# 指令格式

DustISA采用了一种自描述的指令格式，即指令本身就表达了应该如何解析指令。

## 指令结构

DustISA采用32位指令，所有的指令在内存中需要按照32位对齐。

指令的32位被划分为如下的形式：

```
XXX XXX X  XXXXXX XXXXXX XXXXXX XXXXXXX
SET CLA TY R0     R1     R2     INST
```

指令解码器在解析时，需要按照如下规则进行解析：

- SET：区分了不同的子指令集
- CLA：在子指令集中区分区分指令种类
- TY：如果为1，则R0后的指令被编码为19位立即数
- R0：0号寄存器或栈空间
- R1: 1号寄存器或栈空间
- R2: 2号栈空间或寄存器
- INST: 额外的控制参数

### 19位长指令

```
XXX XXX 1  XXXXXX XXXXXXXXXXXXXXXXXXX
SET CLA TY R0     IMM19
```

### 13位长指令

```
XXX XX0 0  XXXXXX XXXXXX XXXXXXXXXXXXX
SET CLA TY R0     R1     IMM13
```

### 普通指令

```
XXX XX1 0  XXXXXX XXXXXX XXXXXX XXXXXXX
SET CLA TY R0.    R1.    R2.    INST
```

## 寄存器或栈空间

指令结构中的R0, R1, R2表达的可以是通用寄存器，或者是栈帧中的某一个地址。最高位为0时则为通用寄存，1位栈帧空间。

### 通用寄存器

DustISA存在32个通用寄存器，其中

- r0为0寄存器
- r1-r31为普通寄存器

### 特殊寄存器

特殊寄存器是无法被指令参数直接访问，需要间接的通过指令访问。这类的寄存器数量不固定，有可能被子指令集扩展。

- PC：指令计数寄存器，永远为32对齐
- SF：栈帧寄存器，永远为32对齐，是指令参数指令为栈空间时的基础偏移量。

### 栈帧空间

SF寄存器会随着函数调用的过程进行增减。由于指令参数有32个取值的可能性，因此随着栈帧的生成与销毁，此寄存器会增加或减少32*字长的偏移量。

假设当前平台字长为64字节，则指令参数读取的栈帧地址为：

SF寄存器 + 栈帧空间编号 * 字长

> 这种设计的假设在于，CPU会将当前执行的栈帧放入缓存中。栈帧的大小并不大，可以被完整的放入缓存中。
